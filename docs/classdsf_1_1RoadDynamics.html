<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Dynamical system model: dsf::RoadDynamics&lt; delay_t &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Dynamical system model
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classdsf_1_1RoadDynamics.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classdsf_1_1RoadDynamics-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">dsf::RoadDynamics&lt; delay_t &gt; Class Template Reference<span class="mlabels"><span class="mlabel abstract">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classdsf_1_1RoadDynamics.html" title="The RoadDynamics class represents the dynamics of the network.">RoadDynamics</a> class represents the dynamics of the network.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;RoadDynamics.hpp&gt;</code></p>
<div class="dynheader">
Inheritance diagram for dsf::RoadDynamics&lt; delay_t &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classdsf_1_1RoadDynamics.png" usemap="#dsf::RoadDynamics_3C_20delay_5Ft_20_3E_map" alt=""/>
  <map id="dsf::RoadDynamics_3C_20delay_5Ft_20_3E_map" name="dsf::RoadDynamics_3C_20delay_5Ft_20_3E_map">
<area href="classdsf_1_1Dynamics.html" alt="dsf::Dynamics&lt; RoadNetwork &gt;" shape="rect" coords="0,0,189,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a00ccd26762a28d14736288c2df05c415" id="r_a00ccd26762a28d14736288c2df05c415"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a00ccd26762a28d14736288c2df05c415">RoadDynamics</a> (<a class="el" href="classdsf_1_1RoadNetwork.html">RoadNetwork</a> &amp;<a class="el" href="classdsf_1_1Dynamics.html#a9f567c709f3bfe87e4f472588d62b668">graph</a>, bool useCache=false, std::optional&lt; unsigned int &gt; seed=std::nullopt, PathWeight const weightFunction=PathWeight::TRAVELTIME, std::optional&lt; double &gt; weightTreshold=std::nullopt)</td></tr>
<tr class="memdesc:a00ccd26762a28d14736288c2df05c415"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new <a class="el" href="classdsf_1_1RoadDynamics.html" title="The RoadDynamics class represents the dynamics of the network.">RoadDynamics</a> object.  <br /></td></tr>
<tr class="separator:a00ccd26762a28d14736288c2df05c415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a305bab5e811a40bf1f0b756228a55026" id="r_a305bab5e811a40bf1f0b756228a55026"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a305bab5e811a40bf1f0b756228a55026">setErrorProbability</a> (double errorProbability)</td></tr>
<tr class="memdesc:a305bab5e811a40bf1f0b756228a55026"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the error probability.  <br /></td></tr>
<tr class="separator:a305bab5e811a40bf1f0b756228a55026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46b9513e32e7d4e9a51eb5238c551014" id="r_a46b9513e32e7d4e9a51eb5238c551014"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a46b9513e32e7d4e9a51eb5238c551014">setPassageProbability</a> (double passageProbability)</td></tr>
<tr class="memdesc:a46b9513e32e7d4e9a51eb5238c551014"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the passage probability.  <br /></td></tr>
<tr class="separator:a46b9513e32e7d4e9a51eb5238c551014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a078f13528c33219fc516d19a92d888cb" id="r_a078f13528c33219fc516d19a92d888cb"><td class="memItemLeft" align="right" valign="top"><a id="a078f13528c33219fc516d19a92d888cb" name="a078f13528c33219fc516d19a92d888cb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setWeightFunction</b> (PathWeight const pathWeight, std::optional&lt; double &gt; weigthThreshold=std::nullopt)</td></tr>
<tr class="separator:a078f13528c33219fc516d19a92d888cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a0005e02fdf5d4d23fa7bcd5a716cbf" id="r_a3a0005e02fdf5d4d23fa7bcd5a716cbf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3a0005e02fdf5d4d23fa7bcd5a716cbf">setForcePriorities</a> (bool forcePriorities) noexcept</td></tr>
<tr class="memdesc:a3a0005e02fdf5d4d23fa7bcd5a716cbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the force priorities flag.  <br /></td></tr>
<tr class="separator:a3a0005e02fdf5d4d23fa7bcd5a716cbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c2883beef1b5ea4321488c0e68abd41" id="r_a7c2883beef1b5ea4321488c0e68abd41"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c2883beef1b5ea4321488c0e68abd41">setDataUpdatePeriod</a> (delay_t dataUpdatePeriod) noexcept</td></tr>
<tr class="memdesc:a7c2883beef1b5ea4321488c0e68abd41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the data update period.  <br /></td></tr>
<tr class="separator:a7c2883beef1b5ea4321488c0e68abd41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae51ee8a184d9cfa00aa81ff4e1772d11" id="r_ae51ee8a184d9cfa00aa81ff4e1772d11"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae51ee8a184d9cfa00aa81ff4e1772d11">setMaxDistance</a> (double const maxDistance)</td></tr>
<tr class="memdesc:ae51ee8a184d9cfa00aa81ff4e1772d11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum distance which a random agent can travel.  <br /></td></tr>
<tr class="separator:ae51ee8a184d9cfa00aa81ff4e1772d11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4be65b0bae3e5b06bab77f1e61cf009b" id="r_a4be65b0bae3e5b06bab77f1e61cf009b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4be65b0bae3e5b06bab77f1e61cf009b">setMaxTravelTime</a> (Time const maxTravelTime) noexcept</td></tr>
<tr class="memdesc:a4be65b0bae3e5b06bab77f1e61cf009b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum travel time which a random agent can travel.  <br /></td></tr>
<tr class="separator:a4be65b0bae3e5b06bab77f1e61cf009b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a708cf681d60d17b2b5d48699b5fc7ca5" id="r_a708cf681d60d17b2b5d48699b5fc7ca5"><td class="memItemLeft" align="right" valign="top"><a id="a708cf681d60d17b2b5d48699b5fc7ca5" name="a708cf681d60d17b2b5d48699b5fc7ca5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setOriginNodes</b> (std::unordered_map&lt; Id, double &gt; const &amp;<a class="el" href="#acd381eeae274aa51b7a4f2c1adee30d4">originNodes</a>)</td></tr>
<tr class="separator:a708cf681d60d17b2b5d48699b5fc7ca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbdf2abc90acec3df304a724eccb416d" id="r_adbdf2abc90acec3df304a724eccb416d"><td class="memItemLeft" align="right" valign="top"><a id="adbdf2abc90acec3df304a724eccb416d" name="adbdf2abc90acec3df304a724eccb416d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setDestinationNodes</b> (std::unordered_map&lt; Id, double &gt; const &amp;<a class="el" href="#a0dbfaf1c018925dc8ae704c7f9657c07">destinationNodes</a>)</td></tr>
<tr class="separator:adbdf2abc90acec3df304a724eccb416d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb87e132ef24175e0346ec45b405b436" id="r_aeb87e132ef24175e0346ec45b405b436"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb87e132ef24175e0346ec45b405b436">setDestinationNodes</a> (std::initializer_list&lt; Id &gt; <a class="el" href="#a0dbfaf1c018925dc8ae704c7f9657c07">destinationNodes</a>)</td></tr>
<tr class="memdesc:aeb87e132ef24175e0346ec45b405b436"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the destination nodes.  <br /></td></tr>
<tr class="separator:aeb87e132ef24175e0346ec45b405b436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdb911e8ba27a1cff4397be2b70d9edf" id="r_afdb911e8ba27a1cff4397be2b70d9edf"><td class="memTemplParams" colspan="2">template&lt;typename TContainer&gt; <br />
requires (std::is_convertible_v&lt;typename TContainer::value_type, Id&gt;)</td></tr>
<tr class="memitem:afdb911e8ba27a1cff4397be2b70d9edf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afdb911e8ba27a1cff4397be2b70d9edf">setDestinationNodes</a> (TContainer const &amp;<a class="el" href="#a0dbfaf1c018925dc8ae704c7f9657c07">destinationNodes</a>)</td></tr>
<tr class="memdesc:afdb911e8ba27a1cff4397be2b70d9edf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the destination nodes.  <br /></td></tr>
<tr class="separator:afdb911e8ba27a1cff4397be2b70d9edf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98bf5266c4f9271e03ddc8c9c46f7385" id="r_a98bf5266c4f9271e03ddc8c9c46f7385"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a98bf5266c4f9271e03ddc8c9c46f7385">setAgentSpeed</a> (std::unique_ptr&lt; <a class="el" href="classdsf_1_1Agent.html">Agent</a> &gt; const &amp;pAgent)=0</td></tr>
<tr class="separator:a98bf5266c4f9271e03ddc8c9c46f7385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad39a4efc94e2c9c1edd9a2337814cae5" id="r_ad39a4efc94e2c9c1edd9a2337814cae5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad39a4efc94e2c9c1edd9a2337814cae5">initTurnCounts</a> ()</td></tr>
<tr class="memdesc:ad39a4efc94e2c9c1edd9a2337814cae5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the turn counts map.  <br /></td></tr>
<tr class="separator:ad39a4efc94e2c9c1edd9a2337814cae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a013b4cbe8af24cdba52d6bbb17f96404" id="r_a013b4cbe8af24cdba52d6bbb17f96404"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a013b4cbe8af24cdba52d6bbb17f96404">resetTurnCounts</a> ()</td></tr>
<tr class="memdesc:a013b4cbe8af24cdba52d6bbb17f96404"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the turn counts map values to zero.  <br /></td></tr>
<tr class="separator:a013b4cbe8af24cdba52d6bbb17f96404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab42842fba9bfca9793a71c5280f0ba59" id="r_ab42842fba9bfca9793a71c5280f0ba59"><td class="memItemLeft" align="right" valign="top"><a id="ab42842fba9bfca9793a71c5280f0ba59" name="ab42842fba9bfca9793a71c5280f0ba59"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>updatePaths</b> ()</td></tr>
<tr class="memdesc:ab42842fba9bfca9793a71c5280f0ba59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the paths of the itineraries based on the given weight function. <br /></td></tr>
<tr class="separator:ab42842fba9bfca9793a71c5280f0ba59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91b29fc463376935108c95035ecdf766" id="r_a91b29fc463376935108c95035ecdf766"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a91b29fc463376935108c95035ecdf766">addAgentsUniformly</a> (Size <a class="el" href="#ab9a52b09ee528c08a5d7832c64ff6ea6">nAgents</a>, std::optional&lt; Id &gt; itineraryId=std::nullopt)</td></tr>
<tr class="memdesc:a91b29fc463376935108c95035ecdf766"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add agents uniformly on the road network.  <br /></td></tr>
<tr class="separator:a91b29fc463376935108c95035ecdf766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe7248ed1e95845ed56228287a3c6a5a" id="r_afe7248ed1e95845ed56228287a3c6a5a"><td class="memTemplParams" colspan="2">template&lt;typename TContainer&gt; <br />
requires (std::is_same_v&lt;TContainer, std::unordered_map&lt;Id, double&gt;&gt; || std::is_same_v&lt;TContainer, std::map&lt;Id, double&gt;&gt;)</td></tr>
<tr class="memitem:afe7248ed1e95845ed56228287a3c6a5a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afe7248ed1e95845ed56228287a3c6a5a">addAgentsRandomly</a> (Size <a class="el" href="#ab9a52b09ee528c08a5d7832c64ff6ea6">nAgents</a>, const TContainer &amp;src_weights, const TContainer &amp;dst_weights)</td></tr>
<tr class="memdesc:afe7248ed1e95845ed56228287a3c6a5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a set of agents to the simulation.  <br /></td></tr>
<tr class="separator:afe7248ed1e95845ed56228287a3c6a5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8caf0f1e86c9721b67674dc88c21f30" id="r_ac8caf0f1e86c9721b67674dc88c21f30"><td class="memItemLeft" align="right" valign="top"><a id="ac8caf0f1e86c9721b67674dc88c21f30" name="ac8caf0f1e86c9721b67674dc88c21f30"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>addAgentsRandomly</b> (Size <a class="el" href="#ab9a52b09ee528c08a5d7832c64ff6ea6">nAgents</a>)</td></tr>
<tr class="separator:ac8caf0f1e86c9721b67674dc88c21f30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d1da8cc97a3ac8197b4ed53919791c7" id="r_a3d1da8cc97a3ac8197b4ed53919791c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d1da8cc97a3ac8197b4ed53919791c7">addAgent</a> (std::unique_ptr&lt; <a class="el" href="classdsf_1_1Agent.html">Agent</a> &gt; agent)</td></tr>
<tr class="memdesc:a3d1da8cc97a3ac8197b4ed53919791c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an agent to the simulation.  <br /></td></tr>
<tr class="separator:a3d1da8cc97a3ac8197b4ed53919791c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f2e0827d1eb7dab32ad6523e938ed65" id="r_a8f2e0827d1eb7dab32ad6523e938ed65"><td class="memTemplParams" colspan="2"><a id="a8f2e0827d1eb7dab32ad6523e938ed65" name="a8f2e0827d1eb7dab32ad6523e938ed65"></a>
template&lt;typename... TArgs&gt; <br />
requires (std::is_constructible_v&lt;<a class="el" href="classdsf_1_1Agent.html">Agent</a>, Time, TArgs...&gt;)</td></tr>
<tr class="memitem:a8f2e0827d1eb7dab32ad6523e938ed65"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>addAgent</b> (TArgs &amp;&amp;... args)</td></tr>
<tr class="separator:a8f2e0827d1eb7dab32ad6523e938ed65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6834bb8f7f9990cdac15af09e6f5b51b" id="r_a6834bb8f7f9990cdac15af09e6f5b51b"><td class="memTemplParams" colspan="2"><a id="a6834bb8f7f9990cdac15af09e6f5b51b" name="a6834bb8f7f9990cdac15af09e6f5b51b"></a>
template&lt;typename... TArgs&gt; <br />
requires (std::is_constructible_v&lt;<a class="el" href="classdsf_1_1Agent.html">Agent</a>, Time, TArgs...&gt;)</td></tr>
<tr class="memitem:a6834bb8f7f9990cdac15af09e6f5b51b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>addAgents</b> (Size <a class="el" href="#ab9a52b09ee528c08a5d7832c64ff6ea6">nAgents</a>, TArgs &amp;&amp;... args)</td></tr>
<tr class="separator:a6834bb8f7f9990cdac15af09e6f5b51b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c30f54c7e310ce41cdcf8e9ab1b4e4d" id="r_a5c30f54c7e310ce41cdcf8e9ab1b4e4d"><td class="memTemplParams" colspan="2">template&lt;typename... TArgs&gt; <br />
requires (std::is_constructible_v&lt;<a class="el" href="classdsf_1_1Itinerary.html">Itinerary</a>, TArgs...&gt;)</td></tr>
<tr class="memitem:a5c30f54c7e310ce41cdcf8e9ab1b4e4d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5c30f54c7e310ce41cdcf8e9ab1b4e4d">addItinerary</a> (TArgs &amp;&amp;... args)</td></tr>
<tr class="memdesc:a5c30f54c7e310ce41cdcf8e9ab1b4e4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an itinerary.  <br /></td></tr>
<tr class="separator:a5c30f54c7e310ce41cdcf8e9ab1b4e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a459b88a50df69aa2fd2c42e473069c0f" id="r_a459b88a50df69aa2fd2c42e473069c0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a459b88a50df69aa2fd2c42e473069c0f">addItinerary</a> (std::unique_ptr&lt; <a class="el" href="classdsf_1_1Itinerary.html">Itinerary</a> &gt; itinerary)</td></tr>
<tr class="memdesc:a459b88a50df69aa2fd2c42e473069c0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an itinerary.  <br /></td></tr>
<tr class="separator:a459b88a50df69aa2fd2c42e473069c0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacd2dd7b6b875cfd9c02815648c7cf6a" id="r_aacd2dd7b6b875cfd9c02815648c7cf6a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aacd2dd7b6b875cfd9c02815648c7cf6a">evolve</a> (bool reinsert_agents=false)</td></tr>
<tr class="memdesc:aacd2dd7b6b875cfd9c02815648c7cf6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evolve the simulation.  <br /></td></tr>
<tr class="separator:aacd2dd7b6b875cfd9c02815648c7cf6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50f6309aae3c5ad16ee6803bd1c0fb44" id="r_a50f6309aae3c5ad16ee6803bd1c0fb44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a50f6309aae3c5ad16ee6803bd1c0fb44">optimizeTrafficLights</a> (TrafficLightOptimization optimizationType=TrafficLightOptimization::DOUBLE_TAIL, const std::string &amp;logFile=std::string(), double const percentage=0.3, double const threshold=1.3)</td></tr>
<tr class="memdesc:a50f6309aae3c5ad16ee6803bd1c0fb44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimize the traffic lights by changing the green and red times.  <br /></td></tr>
<tr class="separator:a50f6309aae3c5ad16ee6803bd1c0fb44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a790aa5901825276884444af49d1a3d9b" id="r_a790aa5901825276884444af49d1a3d9b"><td class="memItemLeft" align="right" valign="top">const std::unordered_map&lt; Id, std::unique_ptr&lt; <a class="el" href="classdsf_1_1Itinerary.html">Itinerary</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a790aa5901825276884444af49d1a3d9b">itineraries</a> () const noexcept</td></tr>
<tr class="memdesc:a790aa5901825276884444af49d1a3d9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the itineraries.  <br /></td></tr>
<tr class="separator:a790aa5901825276884444af49d1a3d9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd381eeae274aa51b7a4f2c1adee30d4" id="r_acd381eeae274aa51b7a4f2c1adee30d4"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; Id, double &gt; const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acd381eeae274aa51b7a4f2c1adee30d4">originNodes</a> () const noexcept</td></tr>
<tr class="memdesc:acd381eeae274aa51b7a4f2c1adee30d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the origin nodes of the graph.  <br /></td></tr>
<tr class="separator:acd381eeae274aa51b7a4f2c1adee30d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dfc540be4814fb5b80d623412fbcf12" id="r_a6dfc540be4814fb5b80d623412fbcf12"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; Id, double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6dfc540be4814fb5b80d623412fbcf12">originNodes</a> () noexcept</td></tr>
<tr class="memdesc:a6dfc540be4814fb5b80d623412fbcf12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the origin nodes of the graph.  <br /></td></tr>
<tr class="separator:a6dfc540be4814fb5b80d623412fbcf12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dbfaf1c018925dc8ae704c7f9657c07" id="r_a0dbfaf1c018925dc8ae704c7f9657c07"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; Id, double &gt; const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0dbfaf1c018925dc8ae704c7f9657c07">destinationNodes</a> () const noexcept</td></tr>
<tr class="memdesc:a0dbfaf1c018925dc8ae704c7f9657c07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the destination nodes of the graph.  <br /></td></tr>
<tr class="separator:a0dbfaf1c018925dc8ae704c7f9657c07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adecc05346d564d065324b42d91efa63c" id="r_adecc05346d564d065324b42d91efa63c"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; Id, double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adecc05346d564d065324b42d91efa63c">destinationNodes</a> () noexcept</td></tr>
<tr class="memdesc:adecc05346d564d065324b42d91efa63c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the destination nodes of the graph.  <br /></td></tr>
<tr class="separator:adecc05346d564d065324b42d91efa63c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0689bcdd253834e1e66f49fe5f4c863d" id="r_a0689bcdd253834e1e66f49fe5f4c863d"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classdsf_1_1Agent.html">Agent</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0689bcdd253834e1e66f49fe5f4c863d">agents</a> () const noexcept</td></tr>
<tr class="memdesc:a0689bcdd253834e1e66f49fe5f4c863d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the agents.  <br /></td></tr>
<tr class="separator:a0689bcdd253834e1e66f49fe5f4c863d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9a52b09ee528c08a5d7832c64ff6ea6" id="r_ab9a52b09ee528c08a5d7832c64ff6ea6"><td class="memItemLeft" align="right" valign="top">Size&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab9a52b09ee528c08a5d7832c64ff6ea6">nAgents</a> () const</td></tr>
<tr class="memdesc:ab9a52b09ee528c08a5d7832c64ff6ea6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of agents currently in the simulation.  <br /></td></tr>
<tr class="separator:ab9a52b09ee528c08a5d7832c64ff6ea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a13caee01e5be9fdc1e6f86c9ef3fe3" id="r_a4a13caee01e5be9fdc1e6f86c9ef3fe3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdsf_1_1Measurement.html">Measurement</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a13caee01e5be9fdc1e6f86c9ef3fe3">meanTravelTime</a> (bool clearData=false)</td></tr>
<tr class="memdesc:a4a13caee01e5be9fdc1e6f86c9ef3fe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the mean travel time of the agents in \(s\).  <br /></td></tr>
<tr class="separator:a4a13caee01e5be9fdc1e6f86c9ef3fe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af337452723e828de8bfa80c4df4e4117" id="r_af337452723e828de8bfa80c4df4e4117"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdsf_1_1Measurement.html">Measurement</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af337452723e828de8bfa80c4df4e4117">meanTravelDistance</a> (bool clearData=false)</td></tr>
<tr class="memdesc:af337452723e828de8bfa80c4df4e4117"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the mean travel distance of the agents in \(m\).  <br /></td></tr>
<tr class="separator:af337452723e828de8bfa80c4df4e4117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47a51d09db32d76edffa269f3978fa26" id="r_a47a51d09db32d76edffa269f3978fa26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdsf_1_1Measurement.html">Measurement</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a47a51d09db32d76edffa269f3978fa26">meanTravelSpeed</a> (bool clearData=false)</td></tr>
<tr class="memdesc:a47a51d09db32d76edffa269f3978fa26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the mean travel speed of the agents in \(m/s\).  <br /></td></tr>
<tr class="separator:a47a51d09db32d76edffa269f3978fa26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af99b94d750cda382ca9ea5bbdef7f4ba" id="r_af99b94d750cda382ca9ea5bbdef7f4ba"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; Id, std::unordered_map&lt; Id, size_t &gt; &gt; const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af99b94d750cda382ca9ea5bbdef7f4ba">turnCounts</a> () const noexcept</td></tr>
<tr class="memdesc:af99b94d750cda382ca9ea5bbdef7f4ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the turn counts of the agents.  <br /></td></tr>
<tr class="separator:af99b94d750cda382ca9ea5bbdef7f4ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6f525faea5e3c1a3d723c56af51c4b2" id="r_ad6f525faea5e3c1a3d723c56af51c4b2"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; Id, std::unordered_map&lt; Id, double &gt; &gt; const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad6f525faea5e3c1a3d723c56af51c4b2">normalizedTurnCounts</a> () const noexcept</td></tr>
<tr class="memdesc:ad6f525faea5e3c1a3d723c56af51c4b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the normalized turn counts of the agents.  <br /></td></tr>
<tr class="separator:ad6f525faea5e3c1a3d723c56af51c4b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec9477a8de4adc987a3fcb7a1fed079f" id="r_aec9477a8de4adc987a3fcb7a1fed079f"><td class="memItemLeft" align="right" valign="top"><a id="aec9477a8de4adc987a3fcb7a1fed079f" name="aec9477a8de4adc987a3fcb7a1fed079f"></a>
std::unordered_map&lt; Id, std::array&lt; long, 4 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>turnMapping</b> () const</td></tr>
<tr class="separator:aec9477a8de4adc987a3fcb7a1fed079f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcfb648e1adf6a893fd9a4a97bc16301" id="r_abcfb648e1adf6a893fd9a4a97bc16301"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abcfb648e1adf6a893fd9a4a97bc16301">streetMeanSpeed</a> (Id streetId) const</td></tr>
<tr class="separator:abcfb648e1adf6a893fd9a4a97bc16301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04d1b440dcc9a3ca2d0985be64f34a4f" id="r_a04d1b440dcc9a3ca2d0985be64f34a4f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structdsf_1_1Measurement.html">Measurement</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a04d1b440dcc9a3ca2d0985be64f34a4f">streetMeanSpeed</a> () const</td></tr>
<tr class="separator:a04d1b440dcc9a3ca2d0985be64f34a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac74dc5c498c909d31bf0abfe04c44f38" id="r_ac74dc5c498c909d31bf0abfe04c44f38"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structdsf_1_1Measurement.html">Measurement</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac74dc5c498c909d31bf0abfe04c44f38">streetMeanSpeed</a> (double, bool) const</td></tr>
<tr class="separator:ac74dc5c498c909d31bf0abfe04c44f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acddbf840f35e58db7ae50678ec64775f" id="r_acddbf840f35e58db7ae50678ec64775f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdsf_1_1Measurement.html">Measurement</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acddbf840f35e58db7ae50678ec64775f">streetMeanDensity</a> (bool normalized=false) const</td></tr>
<tr class="memdesc:acddbf840f35e58db7ae50678ec64775f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the mean density of the streets in \(m^{-1}\).  <br /></td></tr>
<tr class="separator:acddbf840f35e58db7ae50678ec64775f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f3f02bcc1f6ab91a9cb03b53fcc85c2" id="r_a3f3f02bcc1f6ab91a9cb03b53fcc85c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdsf_1_1Measurement.html">Measurement</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f3f02bcc1f6ab91a9cb03b53fcc85c2">streetMeanFlow</a> () const</td></tr>
<tr class="memdesc:a3f3f02bcc1f6ab91a9cb03b53fcc85c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the mean flow of the streets in \(s^{-1}\).  <br /></td></tr>
<tr class="separator:a3f3f02bcc1f6ab91a9cb03b53fcc85c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9840d88dc255f20dbf6ac330d3f50e03" id="r_a9840d88dc255f20dbf6ac330d3f50e03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdsf_1_1Measurement.html">Measurement</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9840d88dc255f20dbf6ac330d3f50e03">streetMeanFlow</a> (double threshold, bool above) const</td></tr>
<tr class="memdesc:a9840d88dc255f20dbf6ac330d3f50e03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the mean flow of the streets in \(s^{-1}\).  <br /></td></tr>
<tr class="separator:a9840d88dc255f20dbf6ac330d3f50e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed3b00ae3effdc362ea0bf541826e8be" id="r_aed3b00ae3effdc362ea0bf541826e8be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdsf_1_1Measurement.html">Measurement</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed3b00ae3effdc362ea0bf541826e8be">meanSpireInputFlow</a> (bool resetValue=true)</td></tr>
<tr class="memdesc:aed3b00ae3effdc362ea0bf541826e8be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the mean spire input flow of the streets in \(s^{-1}\).  <br /></td></tr>
<tr class="separator:aed3b00ae3effdc362ea0bf541826e8be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a557d7bb3ba0444351cc9d4c46db57567" id="r_a557d7bb3ba0444351cc9d4c46db57567"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdsf_1_1Measurement.html">Measurement</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a557d7bb3ba0444351cc9d4c46db57567">meanSpireOutputFlow</a> (bool resetValue=true)</td></tr>
<tr class="memdesc:a557d7bb3ba0444351cc9d4c46db57567"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the mean spire output flow of the streets in \(s^{-1}\).  <br /></td></tr>
<tr class="separator:a557d7bb3ba0444351cc9d4c46db57567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae560afba3e1d566a3da541c0b80c5ab6" id="r_ae560afba3e1d566a3da541c0b80c5ab6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae560afba3e1d566a3da541c0b80c5ab6">saveStreetDensities</a> (const std::string &amp;filename, bool normalized=true, char const separator=';') const</td></tr>
<tr class="memdesc:ae560afba3e1d566a3da541c0b80c5ab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save the street densities in csv format.  <br /></td></tr>
<tr class="separator:ae560afba3e1d566a3da541c0b80c5ab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fb68f2452c68edcfc5067f44207a69d" id="r_a5fb68f2452c68edcfc5067f44207a69d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5fb68f2452c68edcfc5067f44207a69d">saveInputStreetCounts</a> (const std::string &amp;filename, bool reset=false, char const separator=';')</td></tr>
<tr class="memdesc:a5fb68f2452c68edcfc5067f44207a69d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save the street input counts in csv format.  <br /></td></tr>
<tr class="separator:a5fb68f2452c68edcfc5067f44207a69d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15bef633aac816cc06a6f1e31ce002cf" id="r_a15bef633aac816cc06a6f1e31ce002cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a15bef633aac816cc06a6f1e31ce002cf">saveOutputStreetCounts</a> (const std::string &amp;filename, bool reset=false, char const separator=';')</td></tr>
<tr class="memdesc:a15bef633aac816cc06a6f1e31ce002cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save the street output counts in csv format.  <br /></td></tr>
<tr class="separator:a15bef633aac816cc06a6f1e31ce002cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2483dd9185c650d379dcacf930034073" id="r_a2483dd9185c650d379dcacf930034073"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2483dd9185c650d379dcacf930034073">saveTravelData</a> (const std::string &amp;filename, bool reset=false)</td></tr>
<tr class="memdesc:a2483dd9185c650d379dcacf930034073"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save the travel data of the agents in csv format.  <br /></td></tr>
<tr class="separator:a2483dd9185c650d379dcacf930034073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7327efaf122a77a32cd0fc3c559a106" id="r_ad7327efaf122a77a32cd0fc3c559a106"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad7327efaf122a77a32cd0fc3c559a106">saveMacroscopicObservables</a> (const std::string &amp;filename, char const separator=';')</td></tr>
<tr class="memdesc:ad7327efaf122a77a32cd0fc3c559a106"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save the main macroscopic observables in csv format.  <br /></td></tr>
<tr class="separator:ad7327efaf122a77a32cd0fc3c559a106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classdsf_1_1Dynamics"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_classdsf_1_1Dynamics')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classdsf_1_1Dynamics.html">dsf::Dynamics&lt; RoadNetwork &gt;</a></td></tr>
<tr class="memitem:a8d125c0896bf634638849488381d7fab inherit pub_methods_classdsf_1_1Dynamics" id="r_a8d125c0896bf634638849488381d7fab"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdsf_1_1Dynamics.html#a8d125c0896bf634638849488381d7fab">Dynamics</a> (<a class="el" href="classdsf_1_1RoadNetwork.html">RoadNetwork</a> &amp;<a class="el" href="classdsf_1_1Dynamics.html#a9f567c709f3bfe87e4f472588d62b668">graph</a>, std::optional&lt; unsigned int &gt; seed=std::nullopt)</td></tr>
<tr class="memdesc:a8d125c0896bf634638849488381d7fab inherit pub_methods_classdsf_1_1Dynamics"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new <a class="el" href="classdsf_1_1Dynamics.html" title="The Dynamics class represents the dynamics of the network.">Dynamics</a> object.  <br /></td></tr>
<tr class="separator:a8d125c0896bf634638849488381d7fab inherit pub_methods_classdsf_1_1Dynamics"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bf129032d1155b2e7b6bc9032ad0d18 inherit pub_methods_classdsf_1_1Dynamics" id="r_a9bf129032d1155b2e7b6bc9032ad0d18"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>resetTime</b> ()</td></tr>
<tr class="memdesc:a9bf129032d1155b2e7b6bc9032ad0d18 inherit pub_methods_classdsf_1_1Dynamics"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the simulation time to 0. <br /></td></tr>
<tr class="separator:a9bf129032d1155b2e7b6bc9032ad0d18 inherit pub_methods_classdsf_1_1Dynamics"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f567c709f3bfe87e4f472588d62b668 inherit pub_methods_classdsf_1_1Dynamics" id="r_a9f567c709f3bfe87e4f472588d62b668"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdsf_1_1RoadNetwork.html">RoadNetwork</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdsf_1_1Dynamics.html#a9f567c709f3bfe87e4f472588d62b668">graph</a> () const</td></tr>
<tr class="memdesc:a9f567c709f3bfe87e4f472588d62b668 inherit pub_methods_classdsf_1_1Dynamics"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the graph.  <br /></td></tr>
<tr class="separator:a9f567c709f3bfe87e4f472588d62b668 inherit pub_methods_classdsf_1_1Dynamics"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a50d90dea140cc40b82975ca4f3e512 inherit pub_methods_classdsf_1_1Dynamics" id="r_a2a50d90dea140cc40b82975ca4f3e512"><td class="memItemLeft" align="right" valign="top">Time&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdsf_1_1Dynamics.html#a2a50d90dea140cc40b82975ca4f3e512">time</a> () const</td></tr>
<tr class="memdesc:a2a50d90dea140cc40b82975ca4f3e512 inherit pub_methods_classdsf_1_1Dynamics"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current simulation time-step.  <br /></td></tr>
<tr class="separator:a2a50d90dea140cc40b82975ca4f3e512 inherit pub_methods_classdsf_1_1Dynamics"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:adaff501a92316b2cce76c401bb4e17f8" id="r_adaff501a92316b2cce76c401bb4e17f8"><td class="memItemLeft" align="right" valign="top"><a id="adaff501a92316b2cce76c401bb4e17f8" name="adaff501a92316b2cce76c401bb4e17f8"></a>
std::unordered_map&lt; Id, std::unordered_map&lt; Id, size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_turnCounts</b></td></tr>
<tr class="separator:adaff501a92316b2cce76c401bb4e17f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe0ab0989c373dcdbfd65245c09de3f7" id="r_abe0ab0989c373dcdbfd65245c09de3f7"><td class="memItemLeft" align="right" valign="top"><a id="abe0ab0989c373dcdbfd65245c09de3f7" name="abe0ab0989c373dcdbfd65245c09de3f7"></a>
std::unordered_map&lt; Id, std::array&lt; long, 4 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_turnMapping</b></td></tr>
<tr class="separator:abe0ab0989c373dcdbfd65245c09de3f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebbbb584e8b9cc9bdf49dc7242ce2f2d" id="r_aebbbb584e8b9cc9bdf49dc7242ce2f2d"><td class="memItemLeft" align="right" valign="top"><a id="aebbbb584e8b9cc9bdf49dc7242ce2f2d" name="aebbbb584e8b9cc9bdf49dc7242ce2f2d"></a>
tbb::concurrent_unordered_map&lt; Id, std::unordered_map&lt; Direction, double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_queuesAtTrafficLights</b></td></tr>
<tr class="separator:aebbbb584e8b9cc9bdf49dc7242ce2f2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b0431d8a061a2b2469679a8d667b758" id="r_a8b0431d8a061a2b2469679a8d667b758"><td class="memItemLeft" align="right" valign="top"><a id="a8b0431d8a061a2b2469679a8d667b758" name="a8b0431d8a061a2b2469679a8d667b758"></a>
tbb::concurrent_vector&lt; std::pair&lt; double, double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_travelDTs</b></td></tr>
<tr class="separator:a8b0431d8a061a2b2469679a8d667b758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6caeb57798df6165c6b948245cb29e5" id="r_ae6caeb57798df6165c6b948245cb29e5"><td class="memItemLeft" align="right" valign="top"><a id="ae6caeb57798df6165c6b948245cb29e5" name="ae6caeb57798df6165c6b948245cb29e5"></a>
Time&#160;</td><td class="memItemRight" valign="bottom"><b>m_previousOptimizationTime</b></td></tr>
<tr class="separator:ae6caeb57798df6165c6b948245cb29e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb46e501701e6d571dafa4488d4ef49a" id="r_abb46e501701e6d571dafa4488d4ef49a"><td class="memItemLeft" align="right" valign="top"><a id="abb46e501701e6d571dafa4488d4ef49a" name="abb46e501701e6d571dafa4488d4ef49a"></a>
Time&#160;</td><td class="memItemRight" valign="bottom"><b>m_previousSpireTime</b></td></tr>
<tr class="separator:abb46e501701e6d571dafa4488d4ef49a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classdsf_1_1Dynamics"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_attribs_classdsf_1_1Dynamics')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classdsf_1_1Dynamics.html">dsf::Dynamics&lt; RoadNetwork &gt;</a></td></tr>
<tr class="memitem:a2482b1f079dae047d19256e8cc2e8198 inherit pro_attribs_classdsf_1_1Dynamics" id="r_a2482b1f079dae047d19256e8cc2e8198"><td class="memItemLeft" align="right" valign="top">
tbb::task_arena&#160;</td><td class="memItemRight" valign="bottom"><b>m_taskArena</b></td></tr>
<tr class="separator:a2482b1f079dae047d19256e8cc2e8198 inherit pro_attribs_classdsf_1_1Dynamics"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f251fdf7d5c8fa0b8d671dec92e08eb inherit pro_attribs_classdsf_1_1Dynamics" id="r_a6f251fdf7d5c8fa0b8d671dec92e08eb"><td class="memItemLeft" align="right" valign="top">
Time&#160;</td><td class="memItemRight" valign="bottom"><b>m_time</b></td></tr>
<tr class="separator:a6f251fdf7d5c8fa0b8d671dec92e08eb inherit pro_attribs_classdsf_1_1Dynamics"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabbe2c11333ba460e74875e82c40d2ae inherit pro_attribs_classdsf_1_1Dynamics" id="r_aabbe2c11333ba460e74875e82c40d2ae"><td class="memItemLeft" align="right" valign="top">
std::mt19937_64&#160;</td><td class="memItemRight" valign="bottom"><b>m_generator</b></td></tr>
<tr class="separator:aabbe2c11333ba460e74875e82c40d2ae inherit pro_attribs_classdsf_1_1Dynamics"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classdsf_1_1Dynamics"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_methods_classdsf_1_1Dynamics')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classdsf_1_1Dynamics.html">dsf::Dynamics&lt; RoadNetwork &gt;</a></td></tr>
<tr class="memitem:a7a8136a80e0c566246e7917a425923fc inherit pro_methods_classdsf_1_1Dynamics" id="r_a7a8136a80e0c566246e7917a425923fc"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>m_evolve</b> ()</td></tr>
<tr class="separator:a7a8136a80e0c566246e7917a425923fc inherit pro_methods_classdsf_1_1Dynamics"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename delay_t&gt;<br />
requires (is_numeric_v&lt;delay_t&gt;)<br />
class dsf::RoadDynamics&lt; delay_t &gt;</div><p>The <a class="el" href="classdsf_1_1RoadDynamics.html" title="The RoadDynamics class represents the dynamics of the network.">RoadDynamics</a> class represents the dynamics of the network. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">delay_t</td><td>The type of the agent's delay </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a00ccd26762a28d14736288c2df05c415" name="a00ccd26762a28d14736288c2df05c415"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00ccd26762a28d14736288c2df05c415">&#9670;&#160;</a></span>RoadDynamics()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename delay_t&gt; <br />
requires (is_numeric_v&lt;delay_t&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdsf_1_1RoadDynamics.html">dsf::RoadDynamics</a>&lt; delay_t &gt;::RoadDynamics </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdsf_1_1RoadNetwork.html">RoadNetwork</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>graph</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>useCache</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; unsigned int &gt;</td>          <td class="paramname"><span class="paramname"><em>seed</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PathWeight const</td>          <td class="paramname"><span class="paramname"><em>weightFunction</em></span><span class="paramdefsep"> = </span><span class="paramdefval">PathWeight::TRAVELTIME</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; double &gt;</td>          <td class="paramname"><span class="paramname"><em>weightTreshold</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a new <a class="el" href="classdsf_1_1RoadDynamics.html" title="The RoadDynamics class represents the dynamics of the network.">RoadDynamics</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>The graph representing the network </td></tr>
    <tr><td class="paramname">useCache</td><td>If true, the cache is used (default is false) </td></tr>
    <tr><td class="paramname">seed</td><td>The seed for the random number generator (default is std::nullopt) </td></tr>
    <tr><td class="paramname">weightFunction</td><td>The dsf::PathWeight function to use for the pathfinding (default is dsf::PathWeight::TRAVELTIME) </td></tr>
    <tr><td class="paramname">weightTreshold</td><td>The weight treshold for updating the paths (default is std::nullopt) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3d1da8cc97a3ac8197b4ed53919791c7" name="a3d1da8cc97a3ac8197b4ed53919791c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d1da8cc97a3ac8197b4ed53919791c7">&#9670;&#160;</a></span>addAgent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename delay_t&gt; <br />
requires (is_numeric_v&lt;delay_t&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdsf_1_1RoadDynamics.html">dsf::RoadDynamics</a>&lt; delay_t &gt;::addAgent </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classdsf_1_1Agent.html">Agent</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>agent</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an agent to the simulation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">agent</td><td>std::unique_ptr to the agent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afe7248ed1e95845ed56228287a3c6a5a" name="afe7248ed1e95845ed56228287a3c6a5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe7248ed1e95845ed56228287a3c6a5a">&#9670;&#160;</a></span>addAgentsRandomly()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename delay_t&gt; <br />
requires (std::is_same_v&lt;TContainer, std::unordered_map&lt;Id, double&gt;&gt; || std::is_same_v&lt;TContainer, std::map&lt;Id, double&gt;&gt;)</div>
<div class="memtemplate">
template&lt;typename TContainer&gt; <br />
requires (std::is_same_v&lt;TContainer, std::unordered_map&lt;Id, double&gt;&gt; || std::is_same_v&lt;TContainer, std::map&lt;Id, double&gt;&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdsf_1_1RoadDynamics.html">dsf::RoadDynamics</a>&lt; delay_t &gt;::addAgentsRandomly </td>
          <td>(</td>
          <td class="paramtype">Size</td>          <td class="paramname"><span class="paramname"><em>nAgents</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TContainer &amp;</td>          <td class="paramname"><span class="paramname"><em>src_weights</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TContainer &amp;</td>          <td class="paramname"><span class="paramname"><em>dst_weights</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a set of agents to the simulation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nAgents</td><td>The number of agents to add </td></tr>
    <tr><td class="paramname">src_weights</td><td>The weights of the source nodes </td></tr>
    <tr><td class="paramname">dst_weights</td><td>The weights of the destination nodes </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>If the source and destination nodes are the same </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a91b29fc463376935108c95035ecdf766" name="a91b29fc463376935108c95035ecdf766"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91b29fc463376935108c95035ecdf766">&#9670;&#160;</a></span>addAgentsUniformly()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename delay_t&gt; <br />
requires (is_numeric_v&lt;delay_t&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdsf_1_1RoadDynamics.html">dsf::RoadDynamics</a>&lt; delay_t &gt;::addAgentsUniformly </td>
          <td>(</td>
          <td class="paramtype">Size</td>          <td class="paramname"><span class="paramname"><em>nAgents</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; Id &gt;</td>          <td class="paramname"><span class="paramname"><em>itineraryId</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add agents uniformly on the road network. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nAgents</td><td>The number of agents to add </td></tr>
    <tr><td class="paramname">itineraryId</td><td>The id of the itinerary to use (default is std::nullopt) </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If there are no itineraries </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a459b88a50df69aa2fd2c42e473069c0f" name="a459b88a50df69aa2fd2c42e473069c0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a459b88a50df69aa2fd2c42e473069c0f">&#9670;&#160;</a></span>addItinerary() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename delay_t&gt; <br />
requires (is_numeric_v&lt;delay_t&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdsf_1_1RoadDynamics.html">dsf::RoadDynamics</a>&lt; delay_t &gt;::addItinerary </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classdsf_1_1Itinerary.html">Itinerary</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>itinerary</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an itinerary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">itinerary</td><td>std::unique_ptr to the itinerary </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>If the itinerary already exists </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>If the itinerary's destination is not a node of the graph </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5c30f54c7e310ce41cdcf8e9ab1b4e4d" name="a5c30f54c7e310ce41cdcf8e9ab1b4e4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c30f54c7e310ce41cdcf8e9ab1b4e4d">&#9670;&#160;</a></span>addItinerary() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename delay_t&gt; <br />
requires (std::is_constructible_v&lt;<a class="el" href="classdsf_1_1Itinerary.html">Itinerary</a>, TArgs...&gt;)</div>
<div class="memtemplate">
template&lt;typename... TArgs&gt; <br />
requires (std::is_constructible_v&lt;<a class="el" href="classdsf_1_1Itinerary.html">Itinerary</a>, TArgs...&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdsf_1_1RoadDynamics.html">dsf::RoadDynamics</a>&lt; delay_t &gt;::addItinerary </td>
          <td>(</td>
          <td class="paramtype">TArgs &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an itinerary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">...args</td><td>The arguments to construct the itinerary</td></tr>
  </table>
  </dd>
</dl>
<p>The arguments must be compatible with any constructor of the <a class="el" href="classdsf_1_1Itinerary.html" title="The Itinerary class represents an itinerary in the network.">Itinerary</a> class </p>

</div>
</div>
<a id="a0689bcdd253834e1e66f49fe5f4c863d" name="a0689bcdd253834e1e66f49fe5f4c863d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0689bcdd253834e1e66f49fe5f4c863d">&#9670;&#160;</a></span>agents()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename delay_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classdsf_1_1Agent.html">Agent</a> &gt; &gt; &amp; <a class="el" href="classdsf_1_1RoadDynamics.html">dsf::RoadDynamics</a>&lt; delay_t &gt;::agents </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the agents. </p>
<dl class="section return"><dt>Returns</dt><dd>const std::unordered_map&lt;Id, Agent&lt;Id&gt;&gt;&amp;, The agents </dd></dl>

</div>
</div>
<a id="a0dbfaf1c018925dc8ae704c7f9657c07" name="a0dbfaf1c018925dc8ae704c7f9657c07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dbfaf1c018925dc8ae704c7f9657c07">&#9670;&#160;</a></span>destinationNodes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename delay_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt; Id, double &gt; const  &amp; <a class="el" href="classdsf_1_1RoadDynamics.html">dsf::RoadDynamics</a>&lt; delay_t &gt;::destinationNodes </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the destination nodes of the graph. </p>
<dl class="section return"><dt>Returns</dt><dd>std::unordered_map&lt;Id, double&gt; const&amp; The destination nodes of the graph </dd></dl>

</div>
</div>
<a id="adecc05346d564d065324b42d91efa63c" name="adecc05346d564d065324b42d91efa63c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adecc05346d564d065324b42d91efa63c">&#9670;&#160;</a></span>destinationNodes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename delay_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt; Id, double &gt; &amp; <a class="el" href="classdsf_1_1RoadDynamics.html">dsf::RoadDynamics</a>&lt; delay_t &gt;::destinationNodes </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the destination nodes of the graph. </p>
<dl class="section return"><dt>Returns</dt><dd>std::unordered_map&lt;Id, double&gt;&amp; The destination nodes of the graph </dd></dl>

</div>
</div>
<a id="aacd2dd7b6b875cfd9c02815648c7cf6a" name="aacd2dd7b6b875cfd9c02815648c7cf6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacd2dd7b6b875cfd9c02815648c7cf6a">&#9670;&#160;</a></span>evolve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename delay_t&gt; <br />
requires (is_numeric_v&lt;delay_t&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdsf_1_1RoadDynamics.html">dsf::RoadDynamics</a>&lt; delay_t &gt;::evolve </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>reinsert_agents</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evolve the simulation. </p>
<p>Evolve the simulation by moving the agents and updating the travel times. In particular:</p><ul>
<li>Move the first agent of each street queue, if possible, putting it in the next node</li>
<li>Move the agents from each node, if possible, putting them in the next street and giving them a speed. If the error probability is not zero, the agents can move to a random street. If the agent is in the destination node, it is removed from the simulation (and then reinserted if reinsert_agents is true)</li>
<li>Cycle over agents and update their times <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reinsert_agents</td><td>If true, the agents are reinserted in the simulation after they reach their destination </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

</div>
</div>
<a id="ad39a4efc94e2c9c1edd9a2337814cae5" name="ad39a4efc94e2c9c1edd9a2337814cae5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad39a4efc94e2c9c1edd9a2337814cae5">&#9670;&#160;</a></span>initTurnCounts()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename delay_t&gt; <br />
requires (is_numeric_v&lt;delay_t&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdsf_1_1RoadDynamics.html">dsf::RoadDynamics</a>&lt; delay_t &gt;::initTurnCounts </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the turn counts map. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the turn counts map is already initialized </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a790aa5901825276884444af49d1a3d9b" name="a790aa5901825276884444af49d1a3d9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a790aa5901825276884444af49d1a3d9b">&#9670;&#160;</a></span>itineraries()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename delay_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::unordered_map&lt; Id, std::unique_ptr&lt; <a class="el" href="classdsf_1_1Itinerary.html">Itinerary</a> &gt; &gt; &amp; <a class="el" href="classdsf_1_1RoadDynamics.html">dsf::RoadDynamics</a>&lt; delay_t &gt;::itineraries </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the itineraries. </p>
<dl class="section return"><dt>Returns</dt><dd>const std::unordered_map&lt;Id, Itinerary&gt;&amp;, The itineraries </dd></dl>

</div>
</div>
<a id="aed3b00ae3effdc362ea0bf541826e8be" name="aed3b00ae3effdc362ea0bf541826e8be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed3b00ae3effdc362ea0bf541826e8be">&#9670;&#160;</a></span>meanSpireInputFlow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename delay_t&gt; <br />
requires (is_numeric_v&lt;delay_t&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdsf_1_1Measurement.html">Measurement</a>&lt; double &gt; <a class="el" href="classdsf_1_1RoadDynamics.html">dsf::RoadDynamics</a>&lt; delay_t &gt;::meanSpireInputFlow </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>resetValue</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the mean spire input flow of the streets in \(s^{-1}\). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resetValue</td><td>If true, the spire input/output flows are cleared after the computation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structdsf_1_1Measurement.html" title="The Measurement struct represents the mean of a quantity and its standard deviation.">Measurement&lt;double&gt;</a> The mean spire input flow of the streets and the standard deviation</dd></dl>
<p>The spire input flow is computed as the sum of counts over the product of the number of spires and the time delta </p>

</div>
</div>
<a id="a557d7bb3ba0444351cc9d4c46db57567" name="a557d7bb3ba0444351cc9d4c46db57567"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a557d7bb3ba0444351cc9d4c46db57567">&#9670;&#160;</a></span>meanSpireOutputFlow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename delay_t&gt; <br />
requires (is_numeric_v&lt;delay_t&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdsf_1_1Measurement.html">Measurement</a>&lt; double &gt; <a class="el" href="classdsf_1_1RoadDynamics.html">dsf::RoadDynamics</a>&lt; delay_t &gt;::meanSpireOutputFlow </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>resetValue</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the mean spire output flow of the streets in \(s^{-1}\). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resetValue</td><td>If true, the spire output/input flows are cleared after the computation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structdsf_1_1Measurement.html" title="The Measurement struct represents the mean of a quantity and its standard deviation.">Measurement&lt;double&gt;</a> The mean spire output flow of the streets and the standard deviation</dd></dl>
<p>The spire output flow is computed as the sum of counts over the product of the number of spires and the time delta </p>

</div>
</div>
<a id="af337452723e828de8bfa80c4df4e4117" name="af337452723e828de8bfa80c4df4e4117"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af337452723e828de8bfa80c4df4e4117">&#9670;&#160;</a></span>meanTravelDistance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename delay_t&gt; <br />
requires (is_numeric_v&lt;delay_t&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdsf_1_1Measurement.html">Measurement</a>&lt; double &gt; <a class="el" href="classdsf_1_1RoadDynamics.html">dsf::RoadDynamics</a>&lt; delay_t &gt;::meanTravelDistance </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>clearData</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the mean travel distance of the agents in \(m\). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clearData</td><td>If true, the travel distances are cleared after the computation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structdsf_1_1Measurement.html" title="The Measurement struct represents the mean of a quantity and its standard deviation.">Measurement&lt;double&gt;</a> The mean travel distance of the agents and the standard deviation </dd></dl>

</div>
</div>
<a id="a47a51d09db32d76edffa269f3978fa26" name="a47a51d09db32d76edffa269f3978fa26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47a51d09db32d76edffa269f3978fa26">&#9670;&#160;</a></span>meanTravelSpeed()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename delay_t&gt; <br />
requires (is_numeric_v&lt;delay_t&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdsf_1_1Measurement.html">Measurement</a>&lt; double &gt; <a class="el" href="classdsf_1_1RoadDynamics.html">dsf::RoadDynamics</a>&lt; delay_t &gt;::meanTravelSpeed </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>clearData</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the mean travel speed of the agents in \(m/s\). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clearData</td><td>If true, the travel times and distances are cleared after the computation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structdsf_1_1Measurement.html" title="The Measurement struct represents the mean of a quantity and its standard deviation.">Measurement&lt;double&gt;</a> The mean travel speed of the agents and the standard deviation </dd></dl>

</div>
</div>
<a id="a4a13caee01e5be9fdc1e6f86c9ef3fe3" name="a4a13caee01e5be9fdc1e6f86c9ef3fe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a13caee01e5be9fdc1e6f86c9ef3fe3">&#9670;&#160;</a></span>meanTravelTime()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename delay_t&gt; <br />
requires (is_numeric_v&lt;delay_t&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdsf_1_1Measurement.html">Measurement</a>&lt; double &gt; <a class="el" href="classdsf_1_1RoadDynamics.html">dsf::RoadDynamics</a>&lt; delay_t &gt;::meanTravelTime </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>clearData</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the mean travel time of the agents in \(s\). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clearData</td><td>If true, the travel times are cleared after the computation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structdsf_1_1Measurement.html" title="The Measurement struct represents the mean of a quantity and its standard deviation.">Measurement&lt;double&gt;</a> The mean travel time of the agents and the standard deviation </dd></dl>

</div>
</div>
<a id="ab9a52b09ee528c08a5d7832c64ff6ea6" name="ab9a52b09ee528c08a5d7832c64ff6ea6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9a52b09ee528c08a5d7832c64ff6ea6">&#9670;&#160;</a></span>nAgents()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename delay_t&gt; <br />
requires (is_numeric_v&lt;delay_t&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname">Size <a class="el" href="classdsf_1_1RoadDynamics.html">dsf::RoadDynamics</a>&lt; delay_t &gt;::nAgents </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of agents currently in the simulation. </p>
<dl class="section return"><dt>Returns</dt><dd>Size The number of agents </dd></dl>

</div>
</div>
<a id="ad6f525faea5e3c1a3d723c56af51c4b2" name="ad6f525faea5e3c1a3d723c56af51c4b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6f525faea5e3c1a3d723c56af51c4b2">&#9670;&#160;</a></span>normalizedTurnCounts()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename delay_t&gt; <br />
requires (is_numeric_v&lt;delay_t&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt; Id, std::unordered_map&lt; Id, double &gt; &gt; const <a class="el" href="classdsf_1_1RoadDynamics.html">dsf::RoadDynamics</a>&lt; delay_t &gt;::normalizedTurnCounts </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the normalized turn counts of the agents. </p>
<dl class="section return"><dt>Returns</dt><dd>const std::unordered_map&lt;Id, std::unordered_map&lt;Id, double&gt;&gt;&amp; The normalized turn counts. The outer map's key is the street id, the inner map's key is the next street id and the value is the normalized number of counts </dd></dl>

</div>
</div>
<a id="a50f6309aae3c5ad16ee6803bd1c0fb44" name="a50f6309aae3c5ad16ee6803bd1c0fb44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50f6309aae3c5ad16ee6803bd1c0fb44">&#9670;&#160;</a></span>optimizeTrafficLights()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename delay_t&gt; <br />
requires (is_numeric_v&lt;delay_t&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdsf_1_1RoadDynamics.html">dsf::RoadDynamics</a>&lt; delay_t &gt;::optimizeTrafficLights </td>
          <td>(</td>
          <td class="paramtype">TrafficLightOptimization</td>          <td class="paramname"><span class="paramname"><em>optimizationType</em></span><span class="paramdefsep"> = </span><span class="paramdefval">TrafficLightOptimization::DOUBLE_TAIL</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>logFile</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::string()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double const</td>          <td class="paramname"><span class="paramname"><em>percentage</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.3</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double const</td>          <td class="paramname"><span class="paramname"><em>threshold</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1.3</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Optimize the traffic lights by changing the green and red times. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">optimizationType</td><td>TrafficLightOptimization, The type of optimization. Default is DOUBLE_TAIL </td></tr>
    <tr><td class="paramname">logFile</td><td>The file into which write the logs (default is empty, meaning no logging) </td></tr>
    <tr><td class="paramname">percentage</td><td>double, the maximum amount (percentage) of the green time to change (default is 0.3) </td></tr>
    <tr><td class="paramname">threshold</td><td>double, The ratio between the self-density and neighbour density to trigger the non-local optimization (default is 1.3)</td></tr>
  </table>
  </dd>
</dl>
<p>The local optimization is done by changing the green time of each traffic light, trying to make it proportional to the queue lengths at each phase. The non-local optimization is done by synchronizing the traffic lights which are congested over threshold. </p>

</div>
</div>
<a id="acd381eeae274aa51b7a4f2c1adee30d4" name="acd381eeae274aa51b7a4f2c1adee30d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd381eeae274aa51b7a4f2c1adee30d4">&#9670;&#160;</a></span>originNodes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename delay_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt; Id, double &gt; const  &amp; <a class="el" href="classdsf_1_1RoadDynamics.html">dsf::RoadDynamics</a>&lt; delay_t &gt;::originNodes </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the origin nodes of the graph. </p>
<dl class="section return"><dt>Returns</dt><dd>std::unordered_map&lt;Id, double&gt; const&amp; The origin nodes of the graph </dd></dl>

</div>
</div>
<a id="a6dfc540be4814fb5b80d623412fbcf12" name="a6dfc540be4814fb5b80d623412fbcf12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dfc540be4814fb5b80d623412fbcf12">&#9670;&#160;</a></span>originNodes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename delay_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt; Id, double &gt; &amp; <a class="el" href="classdsf_1_1RoadDynamics.html">dsf::RoadDynamics</a>&lt; delay_t &gt;::originNodes </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the origin nodes of the graph. </p>
<dl class="section return"><dt>Returns</dt><dd>std::unordered_map&lt;Id, double&gt;&amp; The origin nodes of the graph </dd></dl>

</div>
</div>
<a id="a013b4cbe8af24cdba52d6bbb17f96404" name="a013b4cbe8af24cdba52d6bbb17f96404"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a013b4cbe8af24cdba52d6bbb17f96404">&#9670;&#160;</a></span>resetTurnCounts()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename delay_t&gt; <br />
requires (is_numeric_v&lt;delay_t&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdsf_1_1RoadDynamics.html">dsf::RoadDynamics</a>&lt; delay_t &gt;::resetTurnCounts </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset the turn counts map values to zero. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the turn counts map is not initialized </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5fb68f2452c68edcfc5067f44207a69d" name="a5fb68f2452c68edcfc5067f44207a69d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fb68f2452c68edcfc5067f44207a69d">&#9670;&#160;</a></span>saveInputStreetCounts()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename delay_t&gt; <br />
requires (is_numeric_v&lt;delay_t&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdsf_1_1RoadDynamics.html">dsf::RoadDynamics</a>&lt; delay_t &gt;::saveInputStreetCounts </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>reset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const</td>          <td class="paramname"><span class="paramname"><em>separator</em></span><span class="paramdefsep"> = </span><span class="paramdefval">';'</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save the street input counts in csv format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The name of the file </td></tr>
    <tr><td class="paramname">reset</td><td>If true, the input counts are cleared after the computation</td></tr>
  </table>
  </dd>
</dl>
<p>NOTE: counts are printed only if the street is a spire </p>

</div>
</div>
<a id="ad7327efaf122a77a32cd0fc3c559a106" name="ad7327efaf122a77a32cd0fc3c559a106"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7327efaf122a77a32cd0fc3c559a106">&#9670;&#160;</a></span>saveMacroscopicObservables()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename delay_t&gt; <br />
requires (is_numeric_v&lt;delay_t&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdsf_1_1RoadDynamics.html">dsf::RoadDynamics</a>&lt; delay_t &gt;::saveMacroscopicObservables </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const</td>          <td class="paramname"><span class="paramname"><em>separator</em></span><span class="paramdefsep"> = </span><span class="paramdefval">';'</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save the main macroscopic observables in csv format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The name of the file </td></tr>
    <tr><td class="paramname">separator</td><td>The separator character (default is ';')</td></tr>
  </table>
  </dd>
</dl>
<p>The file contains the following columns:</p><ul>
<li>time: the time of the simulation</li>
<li>n_agents: the number of agents currently in the simulation</li>
<li>mean_speed - mean_speed_std: the mean speed of the agents</li>
<li>mean_density - mean_density_std: the (normalized) mean density of the streets</li>
<li>mean_flow - mean_flow_std: the mean flow of the streets</li>
<li>mean_flow_spires - mean_flow_spires_std: the mean flow of the spires</li>
<li>mean_traveltime - mean_traveltime_std: the mean travel time of the agents</li>
<li>mean_traveldistance - mean_traveldistance_err: the mean travel distance of the agents</li>
<li>mean_travelspeed - mean_travelspeed_std: the mean travel speed of the agents</li>
</ul>
<p>NOTE: the mean density is normalized in [0, 1] and reset is true for all observables which have such parameter </p>

</div>
</div>
<a id="a15bef633aac816cc06a6f1e31ce002cf" name="a15bef633aac816cc06a6f1e31ce002cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15bef633aac816cc06a6f1e31ce002cf">&#9670;&#160;</a></span>saveOutputStreetCounts()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename delay_t&gt; <br />
requires (is_numeric_v&lt;delay_t&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdsf_1_1RoadDynamics.html">dsf::RoadDynamics</a>&lt; delay_t &gt;::saveOutputStreetCounts </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>reset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const</td>          <td class="paramname"><span class="paramname"><em>separator</em></span><span class="paramdefsep"> = </span><span class="paramdefval">';'</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save the street output counts in csv format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The name of the file </td></tr>
    <tr><td class="paramname">reset</td><td>If true, the output counts are cleared after the computation</td></tr>
  </table>
  </dd>
</dl>
<p>NOTE: counts are printed only if the street is a spire </p>

</div>
</div>
<a id="ae560afba3e1d566a3da541c0b80c5ab6" name="ae560afba3e1d566a3da541c0b80c5ab6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae560afba3e1d566a3da541c0b80c5ab6">&#9670;&#160;</a></span>saveStreetDensities()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename delay_t&gt; <br />
requires (is_numeric_v&lt;delay_t&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdsf_1_1RoadDynamics.html">dsf::RoadDynamics</a>&lt; delay_t &gt;::saveStreetDensities </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>normalized</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const</td>          <td class="paramname"><span class="paramname"><em>separator</em></span><span class="paramdefsep"> = </span><span class="paramdefval">';'</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save the street densities in csv format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The name of the file </td></tr>
    <tr><td class="paramname">normalized</td><td>If true, the densities are normalized in [0, 1] </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2483dd9185c650d379dcacf930034073" name="a2483dd9185c650d379dcacf930034073"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2483dd9185c650d379dcacf930034073">&#9670;&#160;</a></span>saveTravelData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename delay_t&gt; <br />
requires (is_numeric_v&lt;delay_t&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdsf_1_1RoadDynamics.html">dsf::RoadDynamics</a>&lt; delay_t &gt;::saveTravelData </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>reset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save the travel data of the agents in csv format. </p>
<p>The file contains the following columns:</p><ul>
<li>time: the time of the simulation</li>
<li>distances: the travel distances of the agents</li>
<li>times: the travel times of the agents</li>
<li>speeds: the travel speeds of the agents <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The name of the file </td></tr>
    <tr><td class="paramname">reset</td><td>If true, the travel speeds are cleared after the computation </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

</div>
</div>
<a id="a98bf5266c4f9271e03ddc8c9c46f7385" name="a98bf5266c4f9271e03ddc8c9c46f7385"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98bf5266c4f9271e03ddc8c9c46f7385">&#9670;&#160;</a></span>setAgentSpeed()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename delay_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classdsf_1_1RoadDynamics.html">dsf::RoadDynamics</a>&lt; delay_t &gt;::setAgentSpeed </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classdsf_1_1Agent.html">Agent</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>pAgent</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classdsf_1_1FirstOrderDynamics.html#a049c74f6853f61f81b68fd9c65b9b734">dsf::FirstOrderDynamics</a>.</p>

</div>
</div>
<a id="a7c2883beef1b5ea4321488c0e68abd41" name="a7c2883beef1b5ea4321488c0e68abd41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c2883beef1b5ea4321488c0e68abd41">&#9670;&#160;</a></span>setDataUpdatePeriod()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename delay_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdsf_1_1RoadDynamics.html">dsf::RoadDynamics</a>&lt; delay_t &gt;::setDataUpdatePeriod </td>
          <td>(</td>
          <td class="paramtype">delay_t</td>          <td class="paramname"><span class="paramname"><em>dataUpdatePeriod</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the data update period. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataUpdatePeriod</td><td>delay_t, The period</td></tr>
  </table>
  </dd>
</dl>
<p>Some data, i.e. the street queue lengths, are stored only after a fixed amount of time which is represented by this variable. </p>

</div>
</div>
<a id="aeb87e132ef24175e0346ec45b405b436" name="aeb87e132ef24175e0346ec45b405b436"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb87e132ef24175e0346ec45b405b436">&#9670;&#160;</a></span>setDestinationNodes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename delay_t&gt; <br />
requires (is_numeric_v&lt;delay_t&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdsf_1_1RoadDynamics.html">dsf::RoadDynamics</a>&lt; delay_t &gt;::setDestinationNodes </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; Id &gt;</td>          <td class="paramname"><span class="paramname"><em>destinationNodes</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the destination nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destinationNodes</td><td>The destination nodes (as an initializer list) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afdb911e8ba27a1cff4397be2b70d9edf" name="afdb911e8ba27a1cff4397be2b70d9edf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdb911e8ba27a1cff4397be2b70d9edf">&#9670;&#160;</a></span>setDestinationNodes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename delay_t&gt; <br />
requires (std::is_convertible_v&lt;typename TContainer::value_type, Id&gt;)</div>
<div class="memtemplate">
template&lt;typename TContainer&gt; <br />
requires (std::is_convertible_v&lt;typename TContainer::value_type, Id&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdsf_1_1RoadDynamics.html">dsf::RoadDynamics</a>&lt; delay_t &gt;::setDestinationNodes </td>
          <td>(</td>
          <td class="paramtype">TContainer const &amp;</td>          <td class="paramname"><span class="paramname"><em>destinationNodes</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the destination nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destinationNodes</td><td>A container of destination nodes ids</td></tr>
  </table>
  </dd>
</dl>
<p>The container must have a value_type convertible to Id and begin() and end() methods </p>

</div>
</div>
<a id="a305bab5e811a40bf1f0b756228a55026" name="a305bab5e811a40bf1f0b756228a55026"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a305bab5e811a40bf1f0b756228a55026">&#9670;&#160;</a></span>setErrorProbability()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename delay_t&gt; <br />
requires (is_numeric_v&lt;delay_t&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdsf_1_1RoadDynamics.html">dsf::RoadDynamics</a>&lt; delay_t &gt;::setErrorProbability </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>errorProbability</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the error probability. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">errorProbability</td><td>The error probability </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>If the error probability is not between 0 and 1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3a0005e02fdf5d4d23fa7bcd5a716cbf" name="a3a0005e02fdf5d4d23fa7bcd5a716cbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a0005e02fdf5d4d23fa7bcd5a716cbf">&#9670;&#160;</a></span>setForcePriorities()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename delay_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdsf_1_1RoadDynamics.html">dsf::RoadDynamics</a>&lt; delay_t &gt;::setForcePriorities </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>forcePriorities</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the force priorities flag. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">forcePriorities</td><td>The flag</td></tr>
  </table>
  </dd>
</dl>
<p>If true, if an agent cannot move to the next street, the whole node is skipped </p>

</div>
</div>
<a id="ae51ee8a184d9cfa00aa81ff4e1772d11" name="ae51ee8a184d9cfa00aa81ff4e1772d11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae51ee8a184d9cfa00aa81ff4e1772d11">&#9670;&#160;</a></span>setMaxDistance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename delay_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdsf_1_1RoadDynamics.html">dsf::RoadDynamics</a>&lt; delay_t &gt;::setMaxDistance </td>
          <td>(</td>
          <td class="paramtype">double const</td>          <td class="paramname"><span class="paramname"><em>maxDistance</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the maximum distance which a random agent can travel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxDistance</td><td>The maximum distance </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>If the maximum distance is negative </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4be65b0bae3e5b06bab77f1e61cf009b" name="a4be65b0bae3e5b06bab77f1e61cf009b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4be65b0bae3e5b06bab77f1e61cf009b">&#9670;&#160;</a></span>setMaxTravelTime()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename delay_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdsf_1_1RoadDynamics.html">dsf::RoadDynamics</a>&lt; delay_t &gt;::setMaxTravelTime </td>
          <td>(</td>
          <td class="paramtype">Time const</td>          <td class="paramname"><span class="paramname"><em>maxTravelTime</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the maximum travel time which a random agent can travel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxTravelTime</td><td>The maximum travel time </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a46b9513e32e7d4e9a51eb5238c551014" name="a46b9513e32e7d4e9a51eb5238c551014"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46b9513e32e7d4e9a51eb5238c551014">&#9670;&#160;</a></span>setPassageProbability()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename delay_t&gt; <br />
requires (is_numeric_v&lt;delay_t&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdsf_1_1RoadDynamics.html">dsf::RoadDynamics</a>&lt; delay_t &gt;::setPassageProbability </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>passageProbability</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the passage probability. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">passageProbability</td><td>The passage probability</td></tr>
  </table>
  </dd>
</dl>
<p>The passage probability is the probability of passing through a node It is useful in the case of random agents </p>

</div>
</div>
<a id="acddbf840f35e58db7ae50678ec64775f" name="acddbf840f35e58db7ae50678ec64775f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acddbf840f35e58db7ae50678ec64775f">&#9670;&#160;</a></span>streetMeanDensity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename delay_t&gt; <br />
requires (is_numeric_v&lt;delay_t&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdsf_1_1Measurement.html">Measurement</a>&lt; double &gt; <a class="el" href="classdsf_1_1RoadDynamics.html">dsf::RoadDynamics</a>&lt; delay_t &gt;::streetMeanDensity </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>normalized</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the mean density of the streets in \(m^{-1}\). </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structdsf_1_1Measurement.html" title="The Measurement struct represents the mean of a quantity and its standard deviation.">Measurement&lt;double&gt;</a> The mean density of the streets and the standard deviation </dd></dl>

</div>
</div>
<a id="a3f3f02bcc1f6ab91a9cb03b53fcc85c2" name="a3f3f02bcc1f6ab91a9cb03b53fcc85c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f3f02bcc1f6ab91a9cb03b53fcc85c2">&#9670;&#160;</a></span>streetMeanFlow() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename delay_t&gt; <br />
requires (is_numeric_v&lt;delay_t&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdsf_1_1Measurement.html">Measurement</a>&lt; double &gt; <a class="el" href="classdsf_1_1RoadDynamics.html">dsf::RoadDynamics</a>&lt; delay_t &gt;::streetMeanFlow </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the mean flow of the streets in \(s^{-1}\). </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structdsf_1_1Measurement.html" title="The Measurement struct represents the mean of a quantity and its standard deviation.">Measurement&lt;double&gt;</a> The mean flow of the streets and the standard deviation </dd></dl>

</div>
</div>
<a id="a9840d88dc255f20dbf6ac330d3f50e03" name="a9840d88dc255f20dbf6ac330d3f50e03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9840d88dc255f20dbf6ac330d3f50e03">&#9670;&#160;</a></span>streetMeanFlow() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename delay_t&gt; <br />
requires (is_numeric_v&lt;delay_t&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdsf_1_1Measurement.html">Measurement</a>&lt; double &gt; <a class="el" href="classdsf_1_1RoadDynamics.html">dsf::RoadDynamics</a>&lt; delay_t &gt;::streetMeanFlow </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>threshold</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>above</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the mean flow of the streets in \(s^{-1}\). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">threshold</td><td>The density threshold to consider </td></tr>
    <tr><td class="paramname">above</td><td>If true, the function returns the mean flow of the streets with a density above the threshold, otherwise below </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structdsf_1_1Measurement.html" title="The Measurement struct represents the mean of a quantity and its standard deviation.">Measurement&lt;double&gt;</a> The mean flow of the streets and the standard deviation </dd></dl>

</div>
</div>
<a id="a04d1b440dcc9a3ca2d0985be64f34a4f" name="a04d1b440dcc9a3ca2d0985be64f34a4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04d1b440dcc9a3ca2d0985be64f34a4f">&#9670;&#160;</a></span>streetMeanSpeed() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename delay_t&gt; <br />
requires (is_numeric_v&lt;delay_t&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdsf_1_1Measurement.html">Measurement</a>&lt; double &gt; <a class="el" href="classdsf_1_1RoadDynamics.html">dsf::RoadDynamics</a>&lt; delay_t &gt;::streetMeanSpeed </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classdsf_1_1FirstOrderDynamics.html#aeff1a90285aa5c8647a7515439eb46b0">dsf::FirstOrderDynamics</a>.</p>

</div>
</div>
<a id="ac74dc5c498c909d31bf0abfe04c44f38" name="ac74dc5c498c909d31bf0abfe04c44f38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac74dc5c498c909d31bf0abfe04c44f38">&#9670;&#160;</a></span>streetMeanSpeed() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename delay_t&gt; <br />
requires (is_numeric_v&lt;delay_t&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdsf_1_1Measurement.html">Measurement</a>&lt; double &gt; <a class="el" href="classdsf_1_1RoadDynamics.html">dsf::RoadDynamics</a>&lt; delay_t &gt;::streetMeanSpeed </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>threshold</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>above</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classdsf_1_1FirstOrderDynamics.html#ae62fc2d331e91fa645b64ef64dc8fbd3">dsf::FirstOrderDynamics</a>.</p>

</div>
</div>
<a id="abcfb648e1adf6a893fd9a4a97bc16301" name="abcfb648e1adf6a893fd9a4a97bc16301"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcfb648e1adf6a893fd9a4a97bc16301">&#9670;&#160;</a></span>streetMeanSpeed() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename delay_t&gt; <br />
requires (is_numeric_v&lt;delay_t&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classdsf_1_1RoadDynamics.html">dsf::RoadDynamics</a>&lt; delay_t &gt;::streetMeanSpeed </td>
          <td>(</td>
          <td class="paramtype">Id</td>          <td class="paramname"><span class="paramname"><em>streetId</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classdsf_1_1FirstOrderDynamics.html#a32b2d8db994ad4d10e6e1636684b7b91">dsf::FirstOrderDynamics</a>.</p>

</div>
</div>
<a id="af99b94d750cda382ca9ea5bbdef7f4ba" name="af99b94d750cda382ca9ea5bbdef7f4ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af99b94d750cda382ca9ea5bbdef7f4ba">&#9670;&#160;</a></span>turnCounts()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename delay_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt; Id, std::unordered_map&lt; Id, size_t &gt; &gt; const  &amp; <a class="el" href="classdsf_1_1RoadDynamics.html">dsf::RoadDynamics</a>&lt; delay_t &gt;::turnCounts </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the turn counts of the agents. </p>
<dl class="section return"><dt>Returns</dt><dd>const std::unordered_map&lt;Id, std::unordered_map&lt;Id, size_t&gt;&gt;&amp; The turn counts. The outer map's key is the street id, the inner map's key is the next street id and the value is the number of counts </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/dsf/headers/<a class="el" href="RoadDynamics_8hpp.html">RoadDynamics.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacedsf.html">dsf</a></li><li class="navelem"><a class="el" href="classdsf_1_1RoadDynamics.html">RoadDynamics</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
